/**
 * Voice AI SDK
 * JavaScript SDK for integrating voice assistant into any website
 * 
 * @version 1.0.0
 */
(function(window) {
    'use strict';
    const DEFAULT_CONFIG = {
      position: 'bottom-right',
      theme: 'light',
      language: 'en',
      serverUrl: window.location.origin,
      customStyles: {}
    };
    class VoiceAI {
      constructor(config) {
        this.config = { ...DEFAULT_CONFIG, ...config };
        this.clientId = this.config.clientId;
        this.sessionId = null;
        this.isActive = false;
        this.isListening = false;
        this.audioContext = null;
        this.mediaStream = null;
        this.peerConnection = null;
        this.dataChannel = null;
        this.analyser = null;
        this.volumeInterval = null;
        this.currentVolume = 0;
        this.messages = [];
        this.ui = null;
        this.mode = 'idle';
        this.sessionValidationInProgress = false;
        if (!this.clientId) {
          console.error('Voice AI SDK: Client ID is required');
          return;
        }
        this._init();
      }
      /**
       * Initialize the SDK
       * @private
       */
      async _init() {
        try {
          await this._loadSession();
          await this._validateClient();
          await this._initSession();
          this._createUI();
          this._registerEventListeners();
          if (typeof this.config.onReady === 'function') {
            this.config.onReady();
          }
        } catch (error) {
          console.error('Voice AI SDK: Initialization failed', error);
          if (typeof this.config.onError === 'function') {
            this.config.onError(error);
          }
        }
      }
      /**
       * Load session from localStorage and validate it
       * @private
       */
      async _loadSession() {
        try {
          const savedSession = localStorage.getItem('voice_ai_session');
          if (savedSession) {
            const session = JSON.parse(savedSession);
            if (session.clientId === this.clientId) {
              console.log('Voice AI SDK: Found saved session', session.sessionId);
              if (await this._validateSession(session.sessionId)) {
                this.sessionId = session.sessionId;
                console.log('Voice AI SDK: Session validated successfully', this.sessionId);
              } else {
                console.log('Voice AI SDK: Saved session is invalid, will create a new one');
                localStorage.removeItem('voice_ai_session');
                this.sessionId = null;
              }
            } else {
              console.log('Voice AI SDK: Saved session belongs to different client, will create a new one');
              localStorage.removeItem('voice_ai_session');
            }
          } else {
            console.log('Voice AI SDK: No saved session found');
          }
        } catch (error) {
          console.error('Voice AI SDK: Failed to load session', error);
          localStorage.removeItem('voice_ai_session');
          this.sessionId = null;
        }
      }
      /**
       * Validate if a session exists on the server
       * @private
       * @param {string} sessionId - The session ID to validate
       * @returns {Promise<boolean>} - Whether the session is valid
       */
      async _validateSession(sessionId) {
        if (this.sessionValidationInProgress) {
          console.log('Voice AI SDK: Session validation already in progress');
          return false;
        }
        this.sessionValidationInProgress = true;
        try {
          console.log('Voice AI SDK: Validating session', sessionId);
          const response = await fetch(`${this.config.serverUrl}/api/v1/sessions?sessionId=${sessionId}`, {
            method: 'GET'
          });
          this.sessionValidationInProgress = false;
          return response.ok;
        } catch (error) {
          console.error('Voice AI SDK: Session validation failed', error);
          this.sessionValidationInProgress = false;
          return false;
        }
      }
      /**
       * Save session to localStorage
       * @private
       */
      _saveSession() {
        try {
          localStorage.setItem('voice_ai_session', JSON.stringify({
            clientId: this.clientId,
            sessionId: this.sessionId
          }));
          console.log('Voice AI SDK: Session saved to localStorage', this.sessionId);
        } catch (error) {
          console.error('Voice AI SDK: Failed to save session', error);
        }
      }
      /**
       * Validate client with the server
       * @private
       */
      async _validateClient() {
        try {
          const response = await fetch(`${this.config.serverUrl}/api/v1/auth/validate`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              clientId: this.clientId
            })
          });
          const data = await response.json();
          if (!response.ok || !data.valid) {
            throw new Error(data.error || 'Client validation failed');
          }
          console.log('Voice AI SDK: Client validated successfully');
        } catch (error) {
          console.error('Voice AI SDK: Client validation failed', error);
          throw error;
        }
      }
      /**
       * Initialize or restore session
       * @private
       */
      async _initSession() {
        try {
          if (!this.sessionId) {
            console.log('Voice AI SDK: Creating new session');
            const response = await fetch(`${this.config.serverUrl}/api/v1/sessions`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                clientId: this.clientId
              })
            });
            const data = await response.json();
            if (!response.ok) {
              throw new Error(data.error || 'Failed to create session');
            }
            this.sessionId = data.sessionId;
            console.log('Voice AI SDK: New session created', this.sessionId);
            this._saveSession();
          } else {
            console.log('Voice AI SDK: Using existing session', this.sessionId);
          }
        } catch (error) {
          console.error('Voice AI SDK: Session initialization failed', error);
          throw error;
        }
      }
      /**
       * Create UI elements
       * @private
       */
      _createUI() {
        const container = document.createElement('div');
        container.className = 'voice-ai-container';
        container.style.position = 'fixed';
        switch (this.config.position) {
          case 'bottom-right':
            container.style.bottom = '20px';
            container.style.right = '20px';
            break;
          case 'bottom-left':
            container.style.bottom = '20px';
            container.style.left = '20px';
            break;
          case 'top-right':
            container.style.top = '20px';
            container.style.right = '20px';
            break;
          case 'top-left':
            container.style.top = '20px';
            container.style.left = '20px';
            break;
          default:
            container.style.bottom = '20px';
            container.style.right = '20px';
        }
        const button = document.createElement('div');
        button.className = 'voice-ai-button';
        button.style.width = '64px';
        button.style.height = '64px';
        button.style.borderRadius = '50%';
        button.style.backgroundColor = this.config.customStyles.buttonColor || '#3a86ff';
        button.style.display = 'flex';
        button.style.alignItems = 'center';
        button.style.justifyContent = 'center';
        button.style.cursor = 'pointer';
        button.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
        button.style.transition = 'all 0.3s ease';
        const animationContainer = document.createElement('div');
        animationContainer.className = 'voice-ai-animation';
        animationContainer.style.width = '100%';
        animationContainer.style.height = '100%';
        animationContainer.style.display = 'flex';
        animationContainer.style.alignItems = 'center';
        animationContainer.style.justifyContent = 'center';
        const idleAnimation = document.createElement('div');
        idleAnimation.className = 'voice-ai-idle-animation';
        idleAnimation.style.width = '32px';
        idleAnimation.style.height = '32px';
        idleAnimation.style.borderRadius = '50%';
        idleAnimation.style.backgroundColor = '#ffffff';
        idleAnimation.style.opacity = '0.8';
        idleAnimation.style.animation = 'voice-ai-pulse 2s infinite';
        animationContainer.appendChild(idleAnimation);
        button.appendChild(animationContainer);
        container.appendChild(button);
        const style = document.createElement('style');
        style.textContent = `
          @keyframes voice-ai-pulse {
            0% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.5; }
          }
          @keyframes voice-ai-thinking {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.2) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
          }
          @keyframes voice-ai-volume {
            0% { height: 10px; }
            50% { height: 30px; }
            100% { height: 10px; }
          }
        `;
        document.head.appendChild(style);
        document.body.appendChild(container);
        this.ui = {
          container,
          button,
          animationContainer,
          idleAnimation
        };
        button.addEventListener('click', () => {
          this.toggleSession();
        });
      }
      /**
       * Register event listeners
       * @private
       */
      _registerEventListeners() {
        window.addEventListener('beforeunload', () => {
          if (this.isActive) {
            this.stopSession();
          }
        });
      }
      /**
       * Update UI based on mode
       * @private
       * @param {string} mode - The mode to set
       */
      _updateUI(mode, volume = 0) {
        this.uiMode = mode;
        if (!this.ui) return;
        const button = this.ui.button;
        const buttonContainer = this.ui.animationContainer;
        const statusText = this.ui.container.querySelector('.voice-ai-status');
        if (!button || !buttonContainer) return;
        button.classList.remove(
          'voice-ai-active',
          'voice-ai-thinking',
          'voice-ai-responding',
          'voice-ai-error'
        );
        switch (mode) {
          case 'active':
            button.classList.add('voice-ai-active');
            if (statusText) statusText.textContent = 'Listening...';
            break;
          case 'thinking':
            button.classList.add('voice-ai-thinking');
            if (statusText) statusText.textContent = 'Thinking...';
            break;
          case 'responding':
            button.classList.add('voice-ai-responding');
            if (statusText) statusText.textContent = 'Responding...';
            break;
          case 'error':
            button.classList.add('voice-ai-error');
            if (statusText) statusText.textContent = 'Error';
            break;
          case 'volume':
            button.classList.add('voice-ai-active');
            if (statusText) statusText.textContent = 'Listening...';
            let volumeIndicator = this.ui.animationContainer.querySelector('.voice-ai-volume-indicator');
            if (!volumeIndicator) {
              volumeIndicator = document.createElement('div');
              volumeIndicator.className = 'voice-ai-volume-indicator';
              volumeIndicator.style.display = 'flex';
              volumeIndicator.style.justifyContent = 'center';
              volumeIndicator.style.alignItems = 'flex-end';
              volumeIndicator.style.height = '50px';
              volumeIndicator.style.gap = '5px';
              volumeIndicator.style.position = 'absolute';
              volumeIndicator.style.bottom = '80px';
              volumeIndicator.style.left = '50%';
              volumeIndicator.style.transform = 'translateX(-50%)';
              for (let i = 0; i < 4; i++) {
                const bar = document.createElement('div');
                bar.className = 'voice-ai-volume-bar';
                bar.style.width = '4px';
                bar.style.backgroundColor = '#3b82f6';
                bar.style.borderRadius = '2px';
                bar.style.height = '10px';
                bar.style.transition = 'height 0.1s ease';
                volumeIndicator.appendChild(bar);
              }
              buttonContainer.appendChild(volumeIndicator);
            }
            const bars = volumeIndicator.querySelectorAll('.voice-ai-volume-bar');
            bars.forEach(bar => {
              const randomFactor = 0.8 + Math.random() * 0.4;
              const height = Math.max(10, Math.min(50, volume * 500 * randomFactor));
              bar.style.height = `${height}px`;
            });
            volumeIndicator.style.display = 'flex';
            break;
          case 'inactive':
          case 'idle':
          default:
            if (statusText) statusText.textContent = 'Click to talk';
            const volIndicator = this.ui.animationContainer.querySelector('.voice-ai-volume-indicator');
            if (volIndicator) {
              volIndicator.style.display = 'none';
            }
            break;
        }
      }
      /**
       * Configure the WebRTC session
       * @private
       */
      async _configureSession() {
        try {
          console.log('Voice AI SDK: Configuring session with ID:', this.sessionId);
          const offer = await this.peerConnection.createOffer();
          await this.peerConnection.setLocalDescription(offer);
          const response = await fetch(`${this.config.serverUrl}/api/v1/voice/process`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              clientId: this.clientId,
              sessionId: this.sessionId,
              offer: this.peerConnection.localDescription,
              voice: this.config.voice || 'alloy'
            })
          });
          const data = await response.json();
          if (!response.ok) {
            const errorMessage = data.error || 'Failed to configure session';
            if (response.status === 404 && data.newSessionId) {
              console.log('Voice AI SDK: Server provided new session ID:', data.newSessionId);
              this.sessionId = data.newSessionId;
              this._saveSession();
              return this._configureSession();
            }
            if (response.status === 404 && errorMessage.includes('Session not found')) {
              console.log('Voice AI SDK: Session not found, creating a new one');
              this.sessionId = null;
              localStorage.removeItem('voice_ai_session');
              await this._initSession();
              return this._configureSession();
            }
            throw new Error(errorMessage);
          }
          await this.peerConnection.setRemoteDescription(data.answer);
          this.instructions = data.instructions;
          this._updateUI('idle');
          return true;
        } catch (error) {
          console.error('Voice AI SDK: Session configuration failed', error);
          this._updateUI('error');
          throw error;
        }
      }
      /**
       * Data channel open handler
       * @private
       */
      _onDataChannelOpen() {
        console.log('Voice AI SDK: Data channel opened');
        this._configureDataChannel();
        this._updateUI('idle');
      }
      /**
       * Configure data channel with session settings and initial prompt
       * @private
       */
      _configureDataChannel() {
        if (!this.dataChannel || this.dataChannel.readyState !== 'open') {
          console.log('Voice AI SDK: Data channel not open, cannot configure');
          return;
        }
        console.log('Voice AI SDK: Configuring data channel');
        const sendMessages = async () => {
          try {
            console.log('Voice AI SDK: Sending session update');
            const sessionUpdate = {
              type: 'session.update',
              session: {
                modalities: ['text', 'audio'],
                tools: [],
                turn_detection: {
                  type: 'server_vad',
                  threshold: 0.5,
                  prefix_padding_ms: 300,
                  silence_duration_ms: 200,
                  create_response: true
                },
                instructions: this.instructions
              }
            };
            if (this.dataChannel && this.dataChannel.readyState === 'open') {
              this.dataChannel.send(JSON.stringify(sessionUpdate));
              await new Promise(resolve => setTimeout(resolve, 300));
              if (this.dataChannel && this.dataChannel.readyState === 'open') {
                console.log('Voice AI SDK: Sending initial message');
                const startPrompt = {
                  type: 'conversation.item.create',
                  item: {
                    type: 'message',
                    role: 'user',
                    content: [{
                      type: 'input_text',
                      text: 'Begin the conversation by introducing yourself as an Improvado representative'
                    }]
                  }
                };
                this.dataChannel.send(JSON.stringify(startPrompt));
                await new Promise(resolve => setTimeout(resolve, 300));
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                  console.log('Voice AI SDK: Requesting response creation');
                  const createResponse = {
                    type: 'response.create'
                  };
                  this.dataChannel.send(JSON.stringify(createResponse));
                }
              }
            }
          } catch (error) {
            console.error('Voice AI SDK: Error sending messages:', error);
          }
        };
        sendMessages();
      }
      /**
       * Data channel message handler
       * @private
       * @param {MessageEvent} event - The message event
       */
      _onDataChannelMessage(event) {
        try {
          if (!event.data) {
            console.warn('Voice AI SDK: Received empty message');
            return;
          }
          const message = JSON.parse(event.data);
          if (!message.type) {
            console.warn('Voice AI SDK: Received message without type', message);
            return;
          }
          console.log('Voice AI SDK: Received message', message.type);
          this.messages.push(message);
          switch (message.type) {
            case 'input_audio_buffer.speech_started':
              console.log('Voice AI SDK: Speech started');
              this._updateUI('thinking');
              break;
            case 'conversation.item.created':
              console.log('Voice AI SDK: Conversation item created');
              this._updateUI('responding');
              break;
            case 'conversation.item.completed':
              console.log('Voice AI SDK: Conversation item completed');
              this._updateUI('idle');
              break;
            case 'response.function_call_arguments.done':
              console.log('Voice AI SDK: Function call arguments done');
              break;
            default:
              break;
          }
          const customEvent = new CustomEvent('voice-ai-message', {
            detail: { message }
          });
          window.dispatchEvent(customEvent);
        } catch (error) {
          console.error('Voice AI SDK: Error parsing message', error);
        }
      }
      /**
       * Data channel close handler
       * @private
       */
      _onDataChannelClose() {
        console.log('Voice AI SDK: Data channel closed');
        this.isListening = false;
      }
      /**
       * Data channel error handler
       * @private
       * @param {Event} error - The error event
       */
      _onDataChannelError(error) {
        console.error('Voice AI SDK: Data channel error', error);
      }
      /**
       * ICE candidate handler
       * @private
       * @param {RTCPeerConnectionIceEvent} event - The ICE candidate event
       */
      _onIceCandidate(event) {
        if (event.candidate) {
          console.log('Voice AI SDK: New ICE candidate', event.candidate);
        }
      }
      /**
       * Connection state change handler
       * @private
       */
      _onConnectionStateChange() {
        if (!this.peerConnection) return;
        console.log('Voice AI SDK: Connection state changed to', this.peerConnection.connectionState);
        switch (this.peerConnection.connectionState) {
          case 'connected':
            console.log('Voice AI SDK: WebRTC connection established');
            this._updateUI('idle');
            break;
          case 'disconnected':
          case 'failed':
            console.log('Voice AI SDK: WebRTC connection lost');
            this._updateUI('error');
            break;
          case 'closed':
            console.log('Voice AI SDK: WebRTC connection closed');
            this._updateUI('inactive');
            break;
        }
      }
      /**
       * Clean up WebRTC resources
       * @private
       */
      _cleanupWebRTC() {
        this._stopVolumeDetection();
        if (this.dataChannel) {
          this.dataChannel.close();
          this.dataChannel = null;
        }
        if (this.peerConnection) {
          this.peerConnection.close();
          this.peerConnection = null;
        }
        if (this.mediaStream) {
          this.mediaStream.getTracks().forEach(track => track.stop());
          this.mediaStream = null;
        }
        if (this.audioContext) {
          this.audioContext.close().catch(console.error);
          this.audioContext = null;
          this.analyser = null;
        }
        this.isListening = false;
        this.currentVolume = 0;
        this._updateUI('idle');
      }
      /**
       * Start a new session
       * @public
       */
      async startSession() {
        if (this.isActive) return;
        try {
          await this._initWebRTC();
          await this._configureSession();
          this.isActive = true;
          this.isListening = true;
          if (typeof this.config.onStart === 'function') {
            this.config.onStart();
          }
        } catch (error) {
          console.error('Voice AI SDK: Failed to start session', error);
          this._cleanupWebRTC();
          if (typeof this.config.onError === 'function') {
            this.config.onError(error);
          }
        }
      }
      /**
       * Stop the current session
       * @public
       */
      stopSession() {
        console.log('Voice AI SDK: Stopping session');
        if (this.volumeInterval) {
          clearInterval(this.volumeInterval);
          this.volumeInterval = null;
        }
        if (this.volumeTimeout) {
          clearTimeout(this.volumeTimeout);
          this.volumeTimeout = null;
        }
        if (this.audioContext) {
          this.audioContext.close().catch(console.error);
          this.audioContext = null;
          this.analyser = null;
        }
        this._cleanupWebRTC();
        this.isActive = false;
        if (typeof this.config.onEnd === 'function') {
          this.config.onEnd();
        }
      }
      /**
       * Toggle session state
       * @public
       */
      toggleSession() {
        if (this.isActive) {
          this.stopSession();
        } else {
          this.startSession();
        }
      }
      /**
       * Initialize WebRTC
       * @private
       */
      async _initWebRTC() {
        try {
          console.log('Voice AI SDK: Initializing WebRTC');
          this.peerConnection = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' }
            ]
          });
          this.peerConnection.onicecandidate = this._onIceCandidate.bind(this);
          this.peerConnection.onconnectionstatechange = this._onConnectionStateChange.bind(this);
          this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this._setupAudioVisualization(this.stream);
          this.stream.getAudioTracks().forEach(track => {
            this.peerConnection.addTrack(track, this.stream);
          });
          this.audioElement = document.createElement('audio');
          this.audioElement.autoplay = true;
          this.peerConnection.ontrack = (event) => {
            console.log('Voice AI SDK: Received audio track');
            this.audioElement.srcObject = event.streams[0];
          };
          this.dataChannel = this.peerConnection.createDataChannel('response');
          this.dataChannel.onopen = this._onDataChannelOpen.bind(this);
          this.dataChannel.onmessage = this._onDataChannelMessage.bind(this);
          this.dataChannel.onclose = this._onDataChannelClose.bind(this);
          this.dataChannel.onerror = this._onDataChannelError.bind(this);
          const offer = await this.peerConnection.createOffer();
          await this.peerConnection.setLocalDescription(offer);
          console.log('Voice AI SDK: Created offer');
          return true;
        } catch (error) {
          console.error('Voice AI SDK: Error initializing WebRTC', error);
          this._updateUI('error');
          return false;
        }
      }
      _setupAudioVisualization(stream) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);
          const analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;
          source.connect(analyser);
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          const getVolume = () => {
            analyser.getByteTimeDomainData(dataArray);
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
              const float = (dataArray[i] - 128) / 128;
              sum += float * float;
            }
            return Math.sqrt(sum / dataArray.length);
          };
          this.volumeInterval = setInterval(() => {
            const volume = getVolume();
            if (volume > 0.02) {
              this._updateUI('volume', volume);
            } else if (this.uiMode === 'volume') {
              if (!this.volumeTimeout) {
                this.volumeTimeout = setTimeout(() => {
                  this._updateUI('idle');
                  this.volumeTimeout = null;
                }, 500);
              }
            }
          }, 100);
          this.audioContext = audioContext;
          this.analyser = analyser;
        } catch (error) {
          console.error('Voice AI SDK: Error setting up audio visualization', error);
        }
      }
      /**
       * Start volume detection
       * @private
       */
      _startVolumeDetection() {
        if (!this.analyser) return;
        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        this.volumeInterval = setInterval(() => {
          if (!this.analyser) return;
          this.analyser.getByteFrequencyData(dataArray);
          let sum = 0;
          for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i];
          }
          this.currentVolume = sum / bufferLength / 255;
          if (this.isListening && this.currentVolume > 0.02) {
            this._updateUI('volume');
          } else if (this.mode === 'volume') {
            this._updateUI('idle');
          }
        }, 100);
      }
      /**
       * Stop volume detection
       * @private
       */
      _stopVolumeDetection() {
        if (this.volumeInterval) {
          clearInterval(this.volumeInterval);
          this.volumeInterval = null;
        }
      }
    }
    const init = (config) => {
      return new VoiceAI(config);
    };
    window.VoiceAI = {
      init
    };
  })(window);
